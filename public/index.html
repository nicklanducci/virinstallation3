<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <title>Vertical Live Text x4 • Sentence-Triggered Bursts</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; background:#000; color:#fff; overflow:hidden; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }

    .stage { position: fixed; inset: 0; display: flex; justify-content: center; align-items: center; }
    .columns { display: flex; align-items: center; justify-content: center; gap: 6vw; }

    .viewport {
      height: 90vh; width: min(16vw, 220px);
      overflow: hidden; position: relative;
      display: flex; justify-content: center; background:#000;
    }
    .viewport.mode-left  { align-items: flex-end;  } /* nuove parole in basso */
    .viewport.mode-spine { align-items: flex-start;} /* prima parola in alto  */

    .line {
      writing-mode: vertical-rl;
      white-space: nowrap;
      line-height: 1.09;
      font-size: clamp(28px, 6vw, 120px);
      transform-origin: center;
      will-change: transform;
      user-select: none;
    }
    .line.left  { text-orientation: mixed;    transform: rotate(180deg) translateY(0); }
    .line.spine { text-orientation: sideways; transform: translateY(0); }

    .cursor { display:inline-block; width:1ch; text-align:center; animation: blink 1s step-end infinite; }
    .cursor::after { content:"▌"; }
    @keyframes blink { 50% { opacity:0; } }

    .burst {
      position:absolute; inset:0; display:none; z-index:2; background:#000;
      align-items:center; justify-content:center;
    }
    .burst img {
      width:100%; height:100%; object-fit:cover; display:block; background:#111;
    }
    .burst.fallback { background:#700; }

    .controls {
      position: fixed; left: 0; right: 0; bottom: 10px;
      display: flex; gap: .5rem; justify-content: center;
      font-family: inherit;
    }
    input, button {
      background:#111; color:#fff; border:1px solid #333; border-radius:.5rem;
      padding:.6rem .8rem; font-size:16px;
    }
    button { cursor:pointer; }
  </style>
</head>
<body>
  <div class="stage">
    <div class="columns">
      <div class="viewport mode-left"  id="viewport1">
        <div class="line left"  id="line1"><span id="text1"></span><span class="cursor" id="cursor1"></span></div>
        <div class="burst" id="burst1"><img alt=""></div>
      </div>
      <div class="viewport mode-spine" id="viewport2">
        <div class="line spine" id="line2"><span id="text2"></span><span class="cursor" id="cursor2"></span></div>
        <div class="burst" id="burst2"><img alt=""></div>
      </div>
      <div class="viewport mode-left"  id="viewport3">
        <div class="line left"  id="line3"><span id="text3"></span><span class="cursor" id="cursor3"></span></div>
        <div class="burst" id="burst3"><img alt=""></div>
      </div>
      <div class="viewport mode-spine" id="viewport4">
        <div class="line spine" id="line4"><span id="text4"></span><span class="cursor" id="cursor4"></span></div>
        <div class="burst" id="burst4"><img alt=""></div>
      </div>
    </div>
  </div>

  <div class="controls">
    <input id="q" placeholder="Scrivi il prompt (uguale per tutte le colonne)…" size="56" />
    <button id="go">Stream x4</button>
  </div>

  <script>
    /* ===== Readability & Scroll ===== */
    const CHAR_MS=170, SPACE_MS=280, COMMA_MS=520, PERIOD_MS=1000, DASH_MS=650;
    const LEFT_BOTTOM_ROOM_PX=40;  // per colonne 1 & 3
    const SPINE_TOP_ROOM_PX=0;     // per colonne 2 & 4
    const LERP_BASE=0.06, LERP_BOOST=0.10, LAG_THRESHOLD=36;
    const REDUCED_MOTION=matchMedia("(prefers-reduced-motion: reduce)").matches;

    /* ===== Bursts (unique per-frame; unique across columns while active) ===== */
    const BURST_DIR="images2";       // images2/1.png … 96.png
    const BURST_COUNT=96;
    const BURST_MIN=20, BURST_MAX=60;
    const BURST_FRAME_MS=140;
    const ACTIVE_IMAGES=new Set();           // numeri bloccati globalmente finché in uso

    function releaseImages(arr){ for (const n of arr) ACTIVE_IMAGES.delete(n); }
    function candidatePaths(n){
      const s2=n.toString().padStart(2,"0");
      const v=Date.now()+Math.random(); // cache-busting
      return [
        `${BURST_DIR}/${n}.png?v=${v}`,
        `${BURST_DIR}/${n}.PNG?v=${v}`,
        `${BURST_DIR}/${s2}.png?v=${v}`,
        `${BURST_DIR}/${s2}.PNG?v=${v}`,
      ];
    }
    function loadFirstAvailable(paths){
      return new Promise((resolve,reject)=>{
        let i=0; const img=new Image();
        img.onload=()=>resolve(img.src);
        img.onerror=()=>{ i++; if(i>=paths.length) reject(); else img.src=paths[i]; };
        img.src=paths[i];
      });
    }
    const rndInt=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
    const sleep=(ms)=>new Promise(r=>setTimeout(r,ms));

    function delayFor(ch){
      if (ch===" ") return CHAR_MS+SPACE_MS;
      if (/[,\u061B;]/.test(ch)) return CHAR_MS+COMMA_MS;
      if (/[.!?]/.test(ch))      return CHAR_MS+PERIOD_MS;
      if (/[\u2013\u2014-]/.test(ch)) return CHAR_MS+DASH_MS;
      if (ch==="\u2026") return CHAR_MS+PERIOD_MS;
      return CHAR_MS;
    }

    /* ===== Sentence boundary detection (., !, ?, …) ===== */
    const SENTENCE_END_RE = /[.!?…]+(?:["”’']*)\s*$/; // fine frase alla fine del testo/buffer

    /* ===== One streaming column ===== */
    function setupStreamColumn({ sid, mode, viewportId, lineId, textId, burstId }) {
      const viewport=document.getElementById(viewportId);
      const line=document.getElementById(lineId);
      const textSpan=document.getElementById(textId);
      const burstBox=document.getElementById(burstId);
      const burstImg=burstBox.querySelector("img");

      let buffer="";           // chars da riprodurre
      let playing=false;       // player attivo
      let es=null;             // EventSource
      let targetY=0, currentY=0;
      let scrolling=false;

      // Per tagliare lo stream alla prima frase completa
      let finishingThisSentence=false; // stiamo chiudendo alla fine frase
      let cutAtLength=null;            // lunghezza (testo+buffer) dove fermarsi

      function computeTargetY(){
        const contentH=line.scrollHeight, viewH=viewport.clientHeight;
        if (mode==="left"){
          const allowedH=Math.max(0, viewH-LEFT_BOTTOM_ROOM_PX);
          const excess=contentH-allowedH;
          targetY=excess>0?-excess:0;
        } else {
          const allowedH=Math.max(0, viewH-SPINE_TOP_ROOM_PX);
          const excess=contentH-allowedH;
          targetY=excess>0?-excess:0;
        }
      }
      function applyTransform(){
        if (mode==="left") line.style.transform=`rotate(180deg) translateY(${currentY}px)`;
        else               line.style.transform=`translateY(${currentY}px)`;
      }
      function animateScroll(){
        if (scrolling) return;
        scrolling=true;
        (function loop(){
          requestAnimationFrame(loop);
          if (REDUCED_MOTION) currentY=targetY;
          else {
            const lag=targetY-currentY;
            const ease=Math.abs(lag)>LAG_THRESHOLD?LERP_BOOST:LERP_BASE;
            currentY+=lag*ease;
          }
          applyTransform();
        })();
      }
      animateScroll();

      function playLoop(){
        if (playing) return;
        playing=true;
        (function step(){
          // Stop se buffer vuoto o se abbiamo raggiunto il cutAtLength
          if (!buffer.length) { playing=false; return; }

          // Se dobbiamo tagliare a una lunghezza specifica (prima frase), rispettiamola
          if (cutAtLength!=null){
            const already = textSpan.textContent.length;
            if (already >= cutAtLength){
              playing=false; buffer=""; // tutto suonato
              // ora partirà burst (gestito da onStreamCut)
              return;
            }
          }

          const ch=buffer[0]; buffer=buffer.slice(1);
          textSpan.textContent += (ch==="\n") ? " " : ch;

          computeTargetY();
          setTimeout(step, delayFor(ch));
        })();
      }

      function cutStreamAtSentenceEndIfSeen(){
        if (finishingThisSentence) return; // già in corso
        const preview = textSpan.textContent + buffer;
        if (SENTENCE_END_RE.test(preview)){
          // trova l’indice del confine (fine stringa attuale)
          cutAtLength = preview.length;
          finishingThisSentence = true;
          // chiudi lo stream: non vogliamo altre delte oltre la prima frase
          if (es){ try{ es.close(); }catch{} es=null; }
          // quando il player svuota fino a cutAtLength, scatterà il burst
          (async ()=>{
            // attendi che il player consumi fino a cut
            const waitUntil = async () => {
              while (textSpan.textContent.length < cutAtLength){ await sleep(30); }
            };
            await waitUntil();
            await runBurstThenRestart();
          })();
        }
      }

      async function runBurstThenRestart(){
        await runBurstGlobalUnique();
        // reset flags per la prossima frase
        finishingThisSentence=false; cutAtLength=null;
        // ricomincia nuovo stream con stesso prompt
        startStream(currentPromptGlobal);
      }

      async function runBurstGlobalUnique(){
        let frames = rndInt(BURST_MIN, BURST_MAX);

        // crea lista di candidati liberi
        let free=[];
        for (let n=1; n<=BURST_COUNT; n++) if (!ACTIVE_IMAGES.has(n)) free.push(n);
        if (free.length < frames){ free = Array.from({length:BURST_COUNT},(_,i)=>i+1); } // fallback
        // shuffle
        for (let i=free.length-1; i>0; i--){ const j=Math.floor(Math.random()*(i+1)); [free[i],free[j]]=[free[j],free[i]]; }
        const chosen = free.slice(0, frames);
        chosen.forEach(n=> ACTIVE_IMAGES.add(n));

        burstBox.style.display="flex";
        burstBox.classList.remove("fallback");
        line.style.visibility="hidden";

        for (const n of chosen){
          try {
            const src=await loadFirstAvailable(candidatePaths(n));
            burstImg.src = src;
            burstBox.classList.remove("fallback");
          } catch {
            burstImg.removeAttribute("src");
            burstBox.classList.add("fallback");
          }
          await sleep(BURST_FRAME_MS);
        }

        burstBox.style.display="none";
        line.style.visibility="visible";
        releaseImages(chosen);
      }

      function startStream(prompt){
        // reset UI / stato frase
        textSpan.textContent=""; buffer=""; targetY=0; currentY=0;
        finishingThisSentence=false; cutAtLength=null;
        applyTransform(); computeTargetY();

        if (es){ try{ es.close(); }catch{} es=null; }

        // Apri SSE (usa stesso prompt per tutte, ma sid diverso)
        const url = `/stream?prompt=${encodeURIComponent(prompt)}&sid=${encodeURIComponent(sid)}`;
        es = new EventSource(url);

        es.addEventListener("response.output_text.delta", (e)=>{
          try{
            const msg = JSON.parse(e.data);
            if (typeof msg.delta === "string"){
              buffer += msg.delta;
              playLoop();
              cutStreamAtSentenceEndIfSeen(); // controlla se la prima frase è completa
            }
          }catch{}
        });

        // Se il server termina prima che troviamo un punto, chiudiamo “naturalmente”
        es.addEventListener("response.completed", async ()=>{
          try{ es.close(); }catch{} es=null;
          // se non abbiamo fatto cut su una frase, avvia burst ora
          if (!finishingThisSentence){
            // lascia consumare eventuale buffer
            while (buffer.length>0){ await sleep(30); }
            await runBurstThenRestart();
          }
        });

        es.onmessage = (e)=>{
          if (e.data === "[DONE]"){ try{ es.close(); }catch{} es=null; return; }
          try{
            const msg=JSON.parse(e.data);
            if (typeof msg.delta === "string"){
              buffer += msg.delta;
              playLoop();
              cutStreamAtSentenceEndIfSeen();
            }
          }catch{}
        };

        es.onerror = ()=>{
          try{ es.close(); }catch{} es=null;
          // prova a ripartire dopo un attimo
          setTimeout(()=> startStream(prompt), 1200);
        };
      }

      return { startStream };
    }

    /* ===== Wire 4 columns ===== */
    const col1=setupStreamColumn({ sid:"col1", mode:"left",  viewportId:"viewport1", lineId:"line1", textId:"text1", burstId:"burst1" });
    const col2=setupStreamColumn({ sid:"col2", mode:"spine", viewportId:"viewport2", lineId:"line2", textId:"text2", burstId:"burst2" });
    const col3=setupStreamColumn({ sid:"col3", mode:"left",  viewportId:"viewport3", lineId:"line3", textId:"text3", burstId:"burst3" });
    const col4=setupStreamColumn({ sid:"col4", mode:"spine", viewportId:"viewport4", lineId:"line4", textId:"text4", burstId:"burst4" });

    /* ===== Controls ===== */
    const inputEl=document.getElementById("q");
    const goBtn=document.getElementById("go");
    let currentPromptGlobal = "Scrivi una singola frase forte e concettuale sull’arte, adatta a una lettura verticale, senza andare a capo.";

    inputEl.value = currentPromptGlobal;

    function startAll(){
      currentPromptGlobal = (inputEl.value || currentPromptGlobal).trim();
      col1.startStream(currentPromptGlobal);
      col2.startStream(currentPromptGlobal);
      col3.startStream(currentPromptGlobal);
      col4.startStream(currentPromptGlobal);
    }
    startAll();

    goBtn.addEventListener("click", startAll);
    inputEl.addEventListener("keydown", e=>{ if (e.key==="Enter") startAll(); });

    addEventListener("resize", ()=>{ /* ogni colonna autogestisce lo scroll */ });
  </script>
</body>
</html>
