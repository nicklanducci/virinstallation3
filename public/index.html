<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <title>Vertical Live Text x4 • Sentence-Triggered Bursts (JPG)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; background:#000; color:#fff; overflow:hidden; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }

    .stage { position: fixed; inset: 0; display: flex; justify-content: center; align-items: center; }
    .columns { display: flex; align-items: center; justify-content: center; gap: 6vw; }

    .viewport {
      height: 90vh; width: min(16vw, 220px);
      overflow: hidden; position: relative;
      display: flex; justify-content: center; background:#000;
    }
    .viewport.mode-left  { align-items: flex-end; }
    .viewport.mode-spine { align-items: flex-start;}

    .line {
      writing-mode: vertical-rl;
      white-space: nowrap;
      line-height: 1.09;
      font-size: clamp(28px, 6vw, 120px);
      transform-origin: center;
      will-change: transform;
      user-select: none;
    }
    .line.left  { text-orientation: mixed;    transform: rotate(180deg) translateY(0); }
    .line.spine { text-orientation: sideways; transform: translateY(0); }

    .cursor { display:inline-block; width:1ch; text-align:center; animation: blink 1s step-end infinite; }
    .cursor::after { content:"▌"; }
    @keyframes blink { 50% { opacity:0; } }

    .burst {
      position:absolute; inset:0; display:none; z-index:2; background:#000;
      align-items:center; justify-content:center;
    }
    .burst img {
      width:100%; height:100%; object-fit:cover; display:block; background:#111;
    }
    .burst.fallback { background:#700; }

    .controls {
      position: fixed; left: 0; right: 0; bottom: 10px;
      display: flex; gap: .5rem; justify-content: center;
      font-family: inherit;
    }
    input, button {
      background:#111; color:#fff; border:1px solid #333; border-radius:.5rem;
      padding:.6rem .8rem; font-size:16px;
    }
    button { cursor:pointer; }
  </style>
</head>
<body>
  <div class="stage">
    <div class="columns">
      <div class="viewport mode-left"  id="viewport1">
        <div class="line left"  id="line1"><span id="text1"></span><span class="cursor" id="cursor1"></span></div>
        <div class="burst" id="burst1"><img alt=""></div>
      </div>
      <div class="viewport mode-spine" id="viewport2">
        <div class="line spine" id="line2"><span id="text2"></span><span class="cursor" id="cursor2"></span></div>
        <div class="burst" id="burst2"><img alt=""></div>
      </div>
      <div class="viewport mode-left"  id="viewport3">
        <div class="line left"  id="line3"><span id="text3"></span><span class="cursor" id="cursor3"></span></div>
        <div class="burst" id="burst3"><img alt=""></div>
      </div>
      <div class="viewport mode-spine" id="viewport4">
        <div class="line spine" id="line4"><span id="text4"></span><span class="cursor" id="cursor4"></span></div>
        <div class="burst" id="burst4"><img alt=""></div>
      </div>
    </div>
  </div>

  <div class="controls">
    <input id="q" placeholder="Scrivi il prompt (uguale per tutte le colonne)…" size="56" />
    <button id="go">Stream x4</button>
  </div>

  <script>
    const CHAR_MS=170, SPACE_MS=280, COMMA_MS=520, PERIOD_MS=1000, DASH_MS=650;
    const LEFT_BOTTOM_ROOM_PX=40, SPINE_TOP_ROOM_PX=0;
    const LERP_BASE=0.06, LERP_BOOST=0.10, LAG_THRESHOLD=36;
    const REDUCED_MOTION=matchMedia("(prefers-reduced-motion: reduce)").matches;

    const BURST_DIR="images2";   // cartella con 1.jpg … 96.jpg
    const BURST_COUNT=96;
    const BURST_MIN=20, BURST_MAX=60;
    const BURST_FRAME_MS=140;
    const ACTIVE_IMAGES=new Set();

    function releaseImages(arr){ for (const n of arr) ACTIVE_IMAGES.delete(n); }
    function candidatePaths(n){
      const s2=n.toString().padStart(2,"0");
      const v=Date.now()+Math.random();
      return [
        `${BURST_DIR}/${n}.jpg?v=${v}`,
        `${BURST_DIR}/${n}.JPG?v=${v}`,
        `${BURST_DIR}/${s2}.jpg?v=${v}`,
        `${BURST_DIR}/${s2}.JPG?v=${v}`,
      ];
    }
    function loadFirstAvailable(paths){
      return new Promise((resolve,reject)=>{
        let i=0; const img=new Image();
        img.onload=()=>resolve(img.src);
        img.onerror=()=>{ i++; if(i>=paths.length) reject(); else img.src=paths[i]; };
        img.src=paths[i];
      });
    }
    const rndInt=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
    const sleep=(ms)=>new Promise(r=>setTimeout(r,ms));
    function delayFor(ch){
      if (ch===" ") return CHAR_MS+SPACE_MS;
      if (/[,\u061B;]/.test(ch)) return CHAR_MS+COMMA_MS;
      if (/[.!?]/.test(ch))      return CHAR_MS+PERIOD_MS;
      if (/[\u2013\u2014-]/.test(ch)) return CHAR_MS+DASH_MS;
      if (ch==="\u2026") return CHAR_MS+PERIOD_MS;
      return CHAR_MS;
    }
    const SENTENCE_END_RE=/[.!?…]+(?:["”’']*)\s*$/;

    function setupStreamColumn({ sid, mode, viewportId, lineId, textId, burstId }) {
      const viewport=document.getElementById(viewportId);
      const line=document.getElementById(lineId);
      const textSpan=document.getElementById(textId);
      const burstBox=document.getElementById(burstId);
      const burstImg=burstBox.querySelector("img");

      let buffer="", playing=false, es=null;
      let targetY=0, currentY=0, scrolling=false;
      let finishingThisSentence=false, cutAtLength=null;

      function computeTargetY(){
        const contentH=line.scrollHeight, viewH=viewport.clientHeight;
        if (mode==="left"){
          const allowedH=Math.max(0, viewH-LEFT_BOTTOM_ROOM_PX);
          targetY=contentH-allowedH>0 ? -(contentH-allowedH) : 0;
        } else {
          const allowedH=Math.max(0, viewH-SPINE_TOP_ROOM_PX);
          targetY=contentH-allowedH>0 ? -(contentH-allowedH) : 0;
        }
      }
      function applyTransform(){
        if (mode==="left") line.style.transform=`rotate(180deg) translateY(${currentY}px)`;
        else               line.style.transform=`translateY(${currentY}px)`;
      }
      function animateScroll(){
        if (scrolling) return; scrolling=true;
        (function loop(){
          requestAnimationFrame(loop);
          if (REDUCED_MOTION) currentY=targetY;
          else {
            const lag=targetY-currentY;
            const ease=Math.abs(lag)>LAG_THRESHOLD?LERP_BOOST:LERP_BASE;
            currentY+=lag*ease;
          }
          applyTransform();
        })();
      }
      animateScroll();

      function playLoop(){
        if (playing) return; playing=true;
        (function step(){
          if (!buffer.length){ playing=false; return; }
          if (cutAtLength!=null){
            const already=textSpan.textContent.length;
            if (already>=cutAtLength){ playing=false; buffer=""; return; }
          }
          const ch=buffer[0]; buffer=buffer.slice(1);
          textSpan.textContent += (ch==="\n") ? " " : ch;
          computeTargetY();
          setTimeout(step, delayFor(ch));
        })();
      }

      function cutStreamAtSentenceEndIfSeen(){
        if (finishingThisSentence) return;
        const preview=textSpan.textContent+buffer;
        if (SENTENCE_END_RE.test(preview)){
          cutAtLength=preview.length; finishingThisSentence=true;
          if (es){ try{es.close();}catch{} es=null; }
          (async()=>{
            while(textSpan.textContent.length<cutAtLength){ await sleep(30); }
            await runBurstThenRestart();
          })();
        }
      }

      async function runBurstThenRestart(){
        await runBurstGlobalUnique();
        finishingThisSentence=false; cutAtLength=null;
        startStream(currentPromptGlobal);
      }

      async function runBurstGlobalUnique(){
        let frames=rndInt(BURST_MIN,BURST_MAX);
        let free=[]; for(let n=1;n<=BURST_COUNT;n++) if(!ACTIVE_IMAGES.has(n)) free.push(n);
        if (free.length<frames){ free=Array.from({length:BURST_COUNT},(_,i)=>i+1); }
        for(let i=free.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [free[i],free[j]]=[free[j],free[i]]; }
        const chosen=free.slice(0,frames); chosen.forEach(n=>ACTIVE_IMAGES.add(n));

        burstBox.style.display="flex"; line.style.visibility="hidden";
        for(const n of chosen){
          try{ burstImg.src=await loadFirstAvailable(candidatePaths(n)); burstBox.classList.remove("fallback"); }
          catch{ burstImg.removeAttribute("src"); burstBox.classList.add("fallback"); }
          await sleep(BURST_FRAME_MS);
        }
        burstBox.style.display="none"; line.style.visibility="visible"; releaseImages(chosen);
      }

      function startStream(prompt){
        textSpan.textContent=""; buffer=""; targetY=0; currentY=0;
        finishingThisSentence=false; cutAtLength=null; applyTransform(); computeTargetY();
        if (es){ try{es.close();}catch{} es=null; }
        const url=`/stream?prompt=${encodeURIComponent(prompt)}&sid=${encodeURIComponent(sid)}`;
        es=new EventSource(url);

        es.addEventListener("response.output_text.delta",e=>{
          try{ const msg=JSON.parse(e.data);
            if(typeof msg.delta==="string"){ buffer+=msg.delta; playLoop(); cutStreamAtSentenceEndIfSeen(); }
          }catch{}
        });
        es.addEventListener("response.completed",async()=>{
          try{es.close();}catch{} es=null;
          if(!finishingThisSentence){
            while(buffer.length>0){ await sleep(30); }
            await runBurstThenRestart();
          }
        });
        es.onmessage=e=>{
          if(e.data==="[DONE]"){ try{es.close();}catch{} es=null; return; }
          try{ const msg=JSON.parse(e.data);
            if(typeof msg.delta==="string"){ buffer+=msg.delta; playLoop(); cutStreamAtSentenceEndIfSeen(); }
          }catch{}
        };
        es.onerror=()=>{ try{es.close();}catch{} es=null; setTimeout(()=>startStream(prompt),1200); };
      }

      return { startStream };
    }

    const col1=setupStreamColumn({ sid:"col1", mode:"left",  viewportId:"viewport1", lineId:"line1", textId:"text1", burstId:"burst1" });
    const col2=setupStreamColumn({ sid:"col2", mode:"spine", viewportId:"viewport2", lineId:"line2", textId:"text2", burstId:"burst2" });
    const col3=setupStreamColumn({ sid:"col3", mode:"left",  viewportId:"viewport3", lineId:"line3", textId:"text3", burstId:"burst3" });
    const col4=setupStreamColumn({ sid:"col4", mode:"spine", viewportId:"viewport4", lineId:"line4", textId:"text4", burstId:"burst4" });

    const inputEl=document.getElementById("q"); const goBtn=document.getElementById("go");
    let currentPromptGlobal="Scrivi una singola frase, senza andare a capo.";
    inputEl.value=currentPromptGlobal;

    function startAll(){ currentPromptGlobal=(inputEl.value||currentPromptGlobal).trim();
      col1.startStream(currentPromptGlobal); col2.startStream(currentPromptGlobal);
      col3.startStream(currentPromptGlobal); col4.startStream(currentPromptGlobal); }
    startAll();
    goBtn.addEventListener("click",startAll);
    inputEl.addEventListener("keydown",e=>{ if(e.key==="Enter") startAll(); });
  </script>
</body>
</html>
